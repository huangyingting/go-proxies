What does this Repository contain?
==================================
This repository contains two proxy servers, both implemented in Go_:

- gosocksd -- SOCKSv5 proxy server 
- httproxy -- HTTP proxy server

Both are expected to scale well on a modern multi-processor box.
They runs on any platform that is supported
by Go.

Building the servers
---------------------
You need a reasonably new Golang toolchain (1.8+). And the ``go``
executable needs to be in your path. Then run::

    ./build

The script will build several executables and places them in TARGET specific
directories. e.g., for linux-amd64, the binaries will be in ``./bin/linux-amd64``;
and OS X, it will be in ``./bin/darwin-amd64`` and so on.
Each server will produce a single binary.

If you want to build a single program, e.g., ``httproxy``::

    ./build -- httproxy

You can cross-compile by passing appropriate architecture names to
the script. e.g., to build on host OS X for openbsd-amd64::

    ./build --arch=openbsd-amd64 

The script also has other options. To see them::

    ./build --help

``httproxy``
============
This server supports a simple YAML config file for its
configuration. The config file is in ``etc/httproxy.conf``

``gosocksd``
============
The server supports a simple JSON config file for its
configuration. The config file is in ``etc/socksd.conf``


Major features
--------------
- No authentication (yes, its a feature)
- flexible allow/deny rules for discriminating clients
- multiple listeners - each with their own ACL
- Rate limiting incoming connections (per listening IP)

Access Control Rules
--------------------
Go-socksd implements a flexible ACL by combination of
allow/deny rules. The rules are evaluated in the following order:

- If explicitly denied, the host is blocked
- If explicitly allowed, the host is allowed
- Explicit denial takes precedence over explicit allow
- Empty allow list is the same as "allow all"

Example of allow/deny combinations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. Only allow specific subnets and deny everyone else:

    "allow": [ "192.168.55.0/24", "172.16.10.0/24", "127.0.0.1/8" ],
    "deny": []


2. Allow all except selected subnets:

    "allow": [],
    "deny": [ "192.168.80.0/24", "172.16.5.0/24" ]


3. Expliclty block certain hosts and explicitly allow certain
   subnets and block everyone else:

    "allow": [ "192.168.55.0/24", "172.16.10.0/24", "127.0.0.1/8" ],
    "deny":  [ "192.168.1.1/32", "192.168.80.0/24", "172.16.5.0/24" ]



Development Notes
=================
If you are a developer, the notes here will be useful for you:

* The code is written in go. We use vendor branch support to manage
  3rd party repositories.

* We build using two scripts:

   - ``gg`` -- described below
   - ``build`` -- a master shell script to build all the daemons; it does two very
     important things: Puts the binary in an OS/Arch specific directory and
     injects a git version-tag into the final binary ("linker resolved symbol").

* If you are building for the first time, then you have to first prepare the 3rd
  party vendored code::

     ./gg --verbose sync

  This pulls in the required 3rd party libraries and checks out the pinned
  versions. The list of 3rd party dependencies are in ``vendor/manifest.txt``.
  This file is automatically generated by the ``gg`` script.

* Example config files for each daemon is in the ``etc/`` directory.

* Each daemon uses a set of common "local" libraries -- i.e., libraries that are
  meaningful only to the daemons. These are in the ``src/local/`` sub-dirs. In Go,
  these are imported like so (for example)::

    import "local/config"

* Vendor libraries from github are imported using the ``gg`` script like so::

    ./gg get github.com/opencoff/go-libs/options

  And used in code using the usual syntax. The above command fetches the library
  and its dependencies and records them in ``vendor/manifest.txt``.

What is ``gg``
==============
``gg`` is an *augmented* wrapper around 'go' toolchain; it enhances it with
commands needed for painless vendor dependency management. It is in
its own github repository: ``https://github.com/opencoff/gg``

When run from a directory, it implicitly sets ``GOPATH`` to the current
directory and its vendor path. This allows one to structure the code as follows:

- All vendored code goes in ``./vendor/src``
- All local code goes in sub directories of ``./src``
- All local libraries (by convention) go in ``./src/lib``; and imported in code
  as::

    import "lib/module"

General usage help::

    ./gg --help


``gg`` adds the following commands to the tool-chain vocabulary:

* ``fetch``, ``get`` -- fetch and record a new vendor dependency.

* ``update`` -- update one repository from upstream or *all* repositories from
  upstream and update the manifest.

* ``sync`` -- prepare the local directory with the correct checked out version of
  the vendor dependency. This must be run _once_ when a new directory is setup for
  building the entire daemon.

All other commands, it forwards to the 'go' tool. Thus, 'gg' can be used as a
replacement for 'go' for day-to-day use.

Vendor Management
-----------------
Vendor dependencies are recorded in the file ``vendor/manifest.txt``. Each line is
either a comment (starts with '#') or is a dependency record. Each record is a
3-tuple of import-path, upstream-URL, pinned-version.

``gg get`` and ``gg update`` update the manifest. ``gg sync`` consults the
manifest to checkout the correct version.

The checked out vendor code follows the Golang vendor conventions: the code is put
in ``vendor/src``.


Redirect Error
--------------
If you are receiving some error like::

  gopkg.in/h2non/bimg.v1: Cloning and checking out v1.0.6..
  error: RPC failed; HTTP 301 curl 22 The requested URL returned error: 301
  fatal: The remote end hung up unexpectedly

It is because something in git around version 2.11.1 stops following redirects.
A popular repository of golang packages uses this. To workaround, try::

  git config --global http.https://gopkg.in.followRedirects true

.. vim: ft=rst:sw=4:ts=4:expandtab:tw=84:
