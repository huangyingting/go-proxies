What is this?
=============
A simple implementation of HTTP and SOCKSv5 proxy servers in golang.
Both are expected to scale well on a modern multi-processor box.
They runs on any platform that is supported by Go.

Building the servers
---------------------
You need a reasonably new Golang toolchain (1.8+). And the ``go``
executable needs to be in your path. Then run::

    ./build

The script will build ``goproxy`` and places it in TARGET specific
directory. e.g., for linux-amd64, the binaries will be in ``./bin/linux-amd64``;
and OS X, it will be in ``./bin/darwin-amd64`` and so on.

You can cross-compile by passing appropriate architecture names to
the script. e.g., to build on host OS X for openbsd-amd64::

    ./build --arch=openbsd-amd64 

The script also has other options. To see them::

    ./build --help


Usage
-----
The server takes a YAML config file as its sole command line argument. The server
does not fork itself into the background. If you need that capability, explore your
platform's init toolchain (e.g., ``start-stop-daemon``).

The server can run in debug mode::

    ./bin/linux-amd64/goproxy -d etc/goproxy.conf


In debug mode, the logs are sent to STDOUT and the debug level is set to DEBUG
(i.e., verbose).

In the absence of the ``-d`` flag, the default log level is INFO.

Config File
-----------
The server config file is a YAML v2 document. It has a section for HTTP proxy and a
separate section for SOCKSv5 proxy. An example is below::

    # Log file; can be one of:
    #  - Absolute path
    #  - SYSLOG
    #  - STDOUT
    #  - STDERR
    #log: /tmp/goproxy.log
    log: STDOUT

    # Logging level - "DEBUG", "INFO", "WARN", "ERROR"
    loglevel: DEBUG

    # Path to URL Log and response codes
    #urllog:

    # Listeners
    http:
        -
            listen: 127.0.0.1:8080

            # if you want this listener to use a specific outbound IP, then set that
            # here
            #bind:

            # ACL
            allow: [127.0.0.1/8, 11.0.1.0/24, 11.0.2.0/24]
            deny: []

            # limit to N reqs/sec globally
            ratelimit: 2000


    socks:
        -
            listen: 127.0.0.1:2080
            #bind:
            allow: [127.0.0.1/8, 11.0.1.0/24, 11.0.2.0/24]
            deny: []
            # limit to N reqs/sec globally
            ratelimit: 2000



Major features
--------------
- No authentication (yes, its a feature)
- flexible allow/deny rules for discriminating clients
- multiple listeners - each with their own ACL
- Rate limiting incoming connections (global only for now)

Access Control Rules
--------------------
Go-socksd implements a flexible ACL by combination of
allow/deny rules. The rules are evaluated in the following order:

- If explicitly denied, the host is blocked
- If explicitly allowed, the host is allowed
- Explicit denial takes precedence over explicit allow
- Empty allow list is the same as "allow all"

Example of allow/deny combinations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. Only allow specific subnets and deny everyone else:

    allow: [ 192.168.55.0/24, 172.16.10.0/24, 127.0.0.1/8 ],
    deny: []


2. Allow all except selected subnets:

    allow: [],
    deny: [ 192.168.80.0/24", 172.16.5.0/24 ]


3. Expliclty block certain hosts and explicitly allow certain
   subnets and block everyone else:

    allow: [ 192.168.55.0/24, 172.16.10.0/24, 127.0.0.1/8 ],
    deny:  [ 192.168.1.1/32, 192.168.80.0/24, 172.16.5.0/24 ]


Development Notes
=================
If you are a developer, the notes here will be useful for you:

* The code is written in go. We use vendor branch support to manage
  3rd party repositories.

* We build using two scripts:

   - ``gg`` -- described below
   - ``build`` -- a master shell script to build all the daemons; it does two very
     important things: Puts the binary in an OS/Arch specific directory and
     injects a git version-tag into the final binary ("linker resolved symbol").

* If you are building for the first time, then you have to first prepare the 3rd
  party vendored code::

     ./gg --verbose sync

  This pulls in the required 3rd party libraries and checks out the pinned
  versions. The list of 3rd party dependencies are in ``vendor/manifest.txt``.
  This file is automatically generated by the ``gg`` script.

* Example config files is in the ``etc/goproxy.conf`` directory.

* Each daemon uses a set of common "local" libraries -- i.e., libraries that are
  meaningful only to the daemons. These are in the ``src/lib/`` sub-dirs. In Go,
  these are imported like so (for example)::

    import "lib/config"

* Vendor libraries from github are imported using the ``gg`` script like so::

    ./gg get github.com/opencoff/go-libs/options

  And used in code using the usual syntax. The above command fetches the library
  and its dependencies and records them in ``vendor/manifest.txt``.

What is ``gg``
==============
``gg`` is an *augmented* wrapper around 'go' toolchain; it enhances it with
commands needed for painless vendor dependency management. It is in
its own github repository: ``https://github.com/opencoff/gg``

When run from a directory, it implicitly sets ``GOPATH`` to the current
directory and its vendor path. This allows one to structure the code as follows:

- All vendored code goes in ``./vendor/src``
- All local code goes in sub directories of ``./src``
- All local libraries (by convention) go in ``./src/lib``; and imported in code
  as::

    import "lib/module"

General usage help::

    ./gg --help


``gg`` adds the following commands to the tool-chain vocabulary:

* ``fetch``, ``get`` -- fetch and record a new vendor dependency.

* ``update`` -- update one repository from upstream or *all* repositories from
  upstream and update the manifest.

* ``sync`` -- prepare the local directory with the correct checked out version of
  the vendor dependency. This must be run _once_ when a new directory is setup for
  building the entire daemon.

All other commands, it forwards to the 'go' tool. Thus, 'gg' can be used as a
replacement for 'go' for day-to-day use.

Vendor Management
-----------------
Vendor dependencies are recorded in the file ``vendor/manifest.txt``. Each line is
either a comment (starts with '#') or is a dependency record. Each record is a
3-tuple of import-path, upstream-URL, pinned-version.

``gg get`` and ``gg update`` update the manifest. ``gg sync`` consults the
manifest to checkout the correct version.

The checked out vendor code follows the Golang vendor conventions: the code is put
in ``vendor/src``.


Redirect Error
--------------
If you are receiving some error like::

  gopkg.in/h2non/bimg.v1: Cloning and checking out v1.0.6..
  error: RPC failed; HTTP 301 curl 22 The requested URL returned error: 301
  fatal: The remote end hung up unexpectedly

It is because something in git around version 2.11.1 stops following redirects.
A popular repository of golang packages uses this. To workaround, try::

  git config --global http.https://gopkg.in.followRedirects true

.. vim: ft=rst:sw=4:ts=4:expandtab:tw=84:
